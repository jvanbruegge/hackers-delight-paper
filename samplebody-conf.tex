\section{Introduction}

In modern web development enviroments, you need to have at least two types of tools:

\begin{itemize}

\item{\textbf{Compilers:} As most browser vendors have not yet implemented the new ES6 standard natively and many developers want to use one of the many compile-to-javascript languages that are rising in popularity, you need a compiler to transform the source code into the ES5 Javascript standard, that most browser are able to execute. The most popular compilers are \textit{Babel} for ES6, \textit{TSC} for Typescript and \textit{purs} for Purescript.}

\item{\textbf{Bundlers:} Because until ES6 Javascript did not have a syntax to import modules for other source files, you need bundlers that link your code together, provide dependencies and bootstrap your application. Some also generate the \textit{index.html} file with all assets linked or included. The most popular bundler is \textit{webpack}. Other poputlar solutions are \textit{rollup} and \textit{browserify}}

\end{itemize}

The seperation between those two creates a few problems:

\begin{itemize}
\item{It is not possible to optimize across modules, because the compiler is not aware of the other modules' AST}

\item{The bundler has to introduce a runtime to wrap the compiled output, because it is not aware of the AST of the code}

\item{No easy use of multiple lanugages, especially running tests written in multiple languages is hard as testing tools expect Javacript input}

\item{New syntaxes have to be added to all languages individually, for example JSX which was introduced by Facebook and not usable in Typescript for a long time, because Facebook only implemented support in Babel}

\end{itemize}

The fact that most tools are written in Javascript also leads to problems, because Javascript only has limited concurrency and is slow to execute even with modern virtual machines (VM).

To fix those problems, the goal of this paper is to develop a new compiler whose design allows being extended by modules to add new syntaxes to existing languages with minmal efford. To make implementation easier and performance better, the compiler will be written in Haskellcalled \textit{pack.hs}.

\section{Design of the compiler}

\subsection{Classic compiler pipeline}

A classic compiler is implemented as a pipeline of three to five distinct parts (see figure~\ref{fig:compiler_pipeline}).

\begin{figure}[H]
\includegraphics[width=\columnwidth]{./compiler_pipeline.png}
\caption{A classic compiler pipeline}%
\label{fig:compiler_pipeline}
\end{figure}

The lexing step therefore takes the source code to be parsed, together with a Chomsky type 3 grammar that is used to split the raw input string into a ordered set of tokens. This step can be left out, if the characters in the input string are handled as tokens.

A Parser takes then those tokens and a Chomsky type 2 grammar to parse an AST\@. This AST can then be optionally be type checked before it is transformed into the target language. In the context of the web, this most likely Javascript.

In the code generation step, the AST is written into a target file, for Javascript this is another source file. Most of the time this also includes a minification step, where the compiler replaces names with short, obfuscated versions and omits as much whitespace as possible.

\subsection{Pipeline used in pack.hs}

The compiler described in this paper also uses a pipeline approach, but with different steps (see figure~\ref{fig:pack.hs_pipeline}).

\begin{figure}[H]
\includegraphics[width=\columnwidth]{./pack_hs_pipeline.png}
\caption{Compiler pipeline in pack.hs}%
\label{fig:pack.hs_pipeline}
\end{figure}

Here the compiler first collects the grammar files from the plugins, in the current proof of concept implementation, this is just one typescript syntax file. Those grammars are then parsed into a special ABNF grammar AST\@.

This AST is then used to generate a source code parser at runtime, which takes the source code and parses it into an AST\@. To simplify the implementation, there is no type checking done yet.

The last step is again code generation, which transforms the AST into obfuscated and minified Javascript code.
